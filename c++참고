vector
vector<vector<int>> board nxn벡티이면 board.size()=n이다...
vector<int> arr(n+1,1); 백터 1로 초기화
sort(a.begin(),a.end()) end다 기억하자

*max_element(v.begin(), v.end());
max_element(v.begin(), v.end()) - v.begin();가장 큰 수의 인덱스

sort(answer.begin(),answer.end()); 
백터.erase(unique(s.begin(),s.end()),s.end()) 중복제거
copy(arr1.begin(), arr1.end(), arr2.begin()); 백터복사
sort(arr, arr+3, greater<>());내림차순 정렬
v.erase(v.begin()); (무조건 위치 이런걸로 해야한다.)
v.erase(v.begin()+1, v.begin()+4);  1 <= 삭제 < 4
v.insert(v.begin(), 1)


hash
unordered_map<string, int> temp; 중복허용 x
temp.insert(make_pair(gems[i],0);

string
str[i] = toupper(str[i]);대문자 만들기
str[i] = tolower(str[i];)소문자 만들기
string to int stoi(a)
int to string to_string(a)

priority_queue(우선 순위 큐)heap이라 push pop이 가벼움
priority_queue<int, vector<int>, greater<int>> pq; 오름차순
priority_queue<int> pq; 내림차순
pq.top()위에꺼 pq.pop()위에꺼 없애기
